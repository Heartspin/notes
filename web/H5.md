# HTML













# CSS















# JavaScript

## 基础语法

### 认识 JavaScript

- 发明者：布兰登·艾奇（Brendan Eich）
- 网景公司称其为 LiveScript，后加入Sun公司，更名为JavaScript
- JavaScript是运行在客户端的脚本语言（无需编译）
- 可以基于 Node.js 技术进行服务端编程
- 作用：表单动态验证（最初的作用）、网页特效、桌面程序、物联网、游戏开发、服务端

#### 浏览器执行 JavaScript过程

浏览器：渲染引擎（内核）、js引擎（js解释器）

==浏览器并不会去执行js代码，而是通过内置的js引擎来执行js代码==

#### JavaScript的组成

ECMAScript（JavaScript）、DOM（文档对象模型）、BOM（浏览器对象模型）

#### JavaScript书写

1. 行内式

```js
<input type="button" name="button" onclick="alert('行内')" />
```

2. 内嵌式

```js
<head>
	...
	<title>Document</title>
	<script>
    	...
    </script>
</head>
```

3. 外部js文件

```js
// js文件
alert('js文件');

// html文件
<head>
    ...
	<title>Document</title>
	<script src="../"></script>
</head>
```

#### JavaScript注释

单行： // 注释内容(Ctrl+/)

多行： /* 注释内容 */ (shift+alt+A)

#### JavaScript输入输出

```js 
// 输入
prompt();

// 输出
alert();	// 弹出警示框
console.log();	// 控制台输出
```

### 函数

**关键字：**`function`

```js
// 通过关键字声明函数
function 函数名() {
    // 函数体
}

// 函数调用
函数名();
```

> [!CAUTION]
>
> 函数不调用，函数不执行。

#### 函数的参数

```js
function fn(形参1, 形参2, ...) {}

fn(实参1, 实参2, ...);
```

型参与实参的执行过程：

形参类似于一个变量，等待接收实参。函数的参数可有，也可没有。

#### 函数的返回值

**关键字：**`return`

将函数的结果返回给调用函数的对象。

```js
function 函数名() {
    ...
    return ...;
}
函数名();

//
function add(a,b) {
    return a+b;
}
add(3,4);
```

只要函数在执行过程中遇到 `return` 则将函数结果返回给函数的调用者。

> [!IMPORTANT]
>
> 1. `return`语句终止函数，`return`以后的语句不再执行。
>
> 2. `return`只能返回一个值
>
>    ```js
>    return a,b,c;	//只返回c
>    
>    // 如果想要多个值，可以返回数组的形式。
>    return [a,b,c];
>    // 通过遍历将数组中的值取出
>    ```
>
> 3. 函数如果没有`return`则返回`undefind`。



### javaScript对象

对象是由**方法**和**属性**组成的，对象是一个具体的、明确的事物。

- 属性是事物的特征

- 方法是事物的行为

保存一个值时可以采用变量的形式，多个数值时，采用数组的形式。但是不够直观；对象可以保存多个数值，并且结构更加清晰。

#### 创建对象的方式

1. 字面量 `{}`

```js
var obj = {};	// 创建一个空对象
var obj = {
    // 属性,多个属性和方法之间用逗号间隔
    uname: 'andy',
    uage: 18,
    usex: 'man',
    // 方法，采用匿名函数形式
    say: function() {
        console.log('Hi~');
    }
}

// 调用对象属性
// 1. 对象名.属性名
console.log(obj.uname);
// 2. 对象名['属性名']
console.log(obj['uname']);

// 调用对象的方法，对象名.方法名();
obj.say();
```

2. 通过 new Object 创建对象

```js
var obj = new Object();	// 创建了一个空对象
// 追加属性
obj.uname = 'andy';
obj.uage = 18;
// 追加方法
obj.say = function() {
    console.log('Hi~')
};
// 调用方法和属性同上
```

3. 通过构造函数创建对象

前两种方式一次只能创建一个对象，有较高的代码冗余。因此可以通过函数的方式重复利用创建对象的代码，将这样的函数称为构造函数，构造函数内部封装的时对象。

构造函数内部封装的时对象的相同的代码和对象，提高了代码的复用率，结构更加清晰（类似于类）。

```js
// 语法格式
function 构造函数名() {
    this.属性 = 值;
    this.方法 = function() {};
}
// 调用构造函数
// 调用构造函数返回的结构是一个对象
new 构造函数名();
var obj = new 构造函数名();
console.log(typeof(obj))	// Object
```

```js
function Start(uname,uage,usex) {
    this.name = uname;
    this.age = uage;
    this.sex = usex;
    this.sing = function(sang) {
        return sang;
    }
}

var zjl = new Start('zjl',30,'男');
console.log(zjl.name);
console.log(zjl.sing('告白气球'));
```

> [!IMPORTANT]
>
> 1. 构造函数的函数名首字母大写
> 2. 构造函数不需要`return`就能返回结果
> 3. 调用构造函数必须使用`new`
> 4. 只要调用一次构造函数就会产生一个对象
> 5. 构造函数内部的属性和方法前必须使用`this`

**构造函数和对象的联系：**

对象是一个具体的、明确的事物；构造函数是一个泛指的一类事物的统称，类似于C中的类。

通过构造函数创建对象的过程称为对象的实例化。

**`new` 的执行过程:**

1. 首先创建一个空对象
2. `this`指向刚刚创建的空对象
3. 执行构造函数内部代码，为空对象添加属性和方法
4. 返回对象

#### 遍历对象

**目的：**解决单次输出一个属性或方法的反复过程。

```js
console.log(obj.属性1);
console.log(obj.属性2);
console.log(obj.属性3);
...
console.log(obj.fn(a));
console.log(obj.fn(b));
console.log(obj.fn(c));
...
```

逐个的输出属性和方法，过程非常繁琐，代码冗余高。

`for...in` 可以对数组和对象进行循环，建议对对象进行遍历

```js
// 格式
for(var key in 对象) {
    
}
```

```js
// 定义对象
var obj = {
    name: '张三',
    age: 18,
    sex: '男'
}
// 遍历对象
for(var k in ojb) {
   console.log(k); 	// 结果为属性名
   console.log(obj[k])	// 结果为属性值
}
/*
    结果：
    name
    age
    sex

    张三
    18
    男
*/
```

### 内置对象

JavaScript有三种对象：自定义对象、内置对象、浏览器对象

前两种为JavaScript基础，浏览器对象时JavaScript独有。

内置对象是指JavaScript自带的封装函数，开发者无需关心实现过程，只需要直接调用就可，包含：

`Math` `Date` `Array` `String` 等。

> [!NOTE]
>
> 备注：文档参考地址（https://developer.mozilla.org/zh-CN/）



#### Math 对象

Math不是一个构造函数，不需要使用new，直接调用即可。

> [!IMPORTANT]
>
> **参数传递数量 ？**
>
> 当无法确定一个函数在调用时到底传递了几个参数的时候，形参列表无法正常书写，`arguments` 会接收所有传递的实参，此时便无需在书写形参列表。
>
> `arguments` 将传递的参数以数组的形式进行保存。

```js
// arguments
var myMath = function () {
    PI: 3.1415926,
    // 该方法被调用时不知道用户传递参数的数量
    max: function() {
        var k = arguments[0];
        for(var i = 1; i < arguments.lrngth; i++) {
            if (arguments[i] > k) {
                k = arguments[i];
            }
        }
        return k;
    },
        // 该方法被调用时不知道用户传递参数的数量
    min: function() {
        var j = arguments[0];
        for(var n = 1; n < arguments.length; n++) {
            if(arguments[n] < j) {
                j = arguments[n];
            }
        }
        return j;
    }
};
```

`Math.floor()` : 向下取整

```js
console.log(Math.floor(1.1));
console.log(Math.floor(1.6));
// 1
// 1
```

`Math.ceil()` : 向上取整

```js
console.log(Math.ceil(1.1));
console.log(Math.ceil(1.9));
// 2
// 2
```

`Math.round()` : 四舍五入

```js
console.log(Math.round(1.1));
console.log(Math.round(1.6));
console.log(Math.round(1.5));
console.log(Math.round(-1.1));
console.log(Math.round(-1.6));
console.log(Math.round(-1.5));
// 1
// 2
// 2
// -1
// -2
// -1
```

> [!CAUTION]
>
> 对于正数，四舍五入能正常舍入。对于 `(-)x.5` 形式的数字，会向着 `X` 轴正方向舍入。

##### Math.random()

- 返回值时介于 [0, 1) 之间的浮点数。
- 无参

#### Date 对象

- Date 是一个构造函数，必须使用 new 来创建一个 Date 对象

- 无参，返回系统的当前时间

- 带参，参数类型：

  - 数字型 2019,10,1
  - 字符型 '2019-10-18 8:8:8'

  ```js
  var date = new Date(2020,10,11);
  var date1 = new Date('2020-1-11 10:10:10');
  ```

##### 日期格式化

```js
var date = new Date();
date.getFull*();
// 包含：Year Month Date Day （年、月、日、周） Hours Minutes Seconds (时、分、秒)
```

> [!CAUTION]
>
> 返回的周日的序号为 0，返回的月份的序号是从 0 开始的，因此要 +1

##### 获取总毫秒数(时间戳)

距离1970年1月1好距今的总毫秒数

1. valueOf()
2. getTime()

```js
var date = newDate();
date.valueOf();
date.getTime();

// 简化写法
var date1 = +new Date();
// H5写法
Date.now();
```

#### 数组对象

##### 创建数组的方式

1. 字面量 []

```js
var arr = []
```

2. 构造函数

```js
// 创建长度为 num 的空数组
var arr = new Array(num);

// 创建包含元素的数组
var arr = new Array(num1, num2, ...);
```

##### 检测是否为数组

1. instanceof 运算符

```js
var arr = [];
var obj = {};
arr instanceof Array	// true
obj instanceof Array	// false
```

2. Array.isArray(参数) H5方法

```js
var arr = [];
var obj = {};
Array.isArray(arr);	// true
Array.isArray(obj);	// false
```

##### 添加或者删除数组元素

1. push(num1,num2,...) 末尾添加一个或多个元素

```js
var arr = [1,2,3];
arr.push(4, 5);
// 返回值 新数组长度
```

2. unshift(num1,num2,...) 在数组的开头添加一个或多个元素

```js
var arr = [1,2,3];
arr.unshift(4,5);
// 返回值 新数组的长度
```

3. pop() 删除数组的最后一个元素

```js
var arr = [1,2,3];
arr.pop();
// 返回值 删除的元素
```

4. shift() 删除数组的第一个元素

```js
var arr = [];
arr.shift();
// 返回值 删除的元素
```

##### 数组排序

1. 翻转数组 reverse()

```js
var arr = [1,2,3,4];
// 翻转
arr.reverse();
```

2. 数组排序 sort()

```js
var arr = [1,17,13,3,24,2];
//
arr.sort(); // [1,13,17,2,24,3] sort会先看第一位数字	
// 标准写法
arr.sort(function(a, b) {
   return a-b;	//按照升序排列
   return b-a;	//按照降序排列
});
```

##### 数组索引

```js
// 返回数组元素的索引号
var arr = [1,2,3,4,5,6];

// 1.indexOf(数组元素) 从前向后查找
arr.indexOf(3);

// 2.lastIndexOf(数组元素) 从后向前
arr.lastIndexOf(4);
```

> [!CAUTION]
>
> 1. indexOf()自会返回他第一次遇到的目标元素的索引号，之后便不会再继续查找
> 2. 如果查找的元素不在数组中，indexOf()返回 -1 
> 3. lastIndexOf()返回值并不会因为查找方向的变化而改变元素在数组中的真实的索引号

##### 数组转为字符串

1. toString()

```js
var arr = [1,2,3];
arr.toString();	// 1,2,3
```

2. join(分隔符)

```js
arr.join('-');	// 1-2-3
```

##### 数组的连接和删除

1. concat([arr1,num1,...]) 返回一个新的 Array，不改变原来的数组

```js
var arr = [1,2,3];
var arr2 = [4,5];
var arr3 = [6,7];
// 无参
arr.concat();	// 对原数组创建一个副本，副本并没有开辟存储空间，只是指向了原数组的存储地址
// 单参
arr.concat(arr1);
```



#### 字符串对象

为了便于操作JavaScript提供了三种特殊的引用类型 `String Number Boolen` 

==基本包装类型==：把简单的数据类型包装成复杂数据类型，这样简单数据类型，就有了属性和方法

##### 字符串不可变

对字符串而言，每当给变量一个新的字符串，就会重新开辟一个内存空间存放新值且原来的不会消失，因此不要进行大量的字符串拼接操作。

看似改变了值，实际只是改变了内存地址的指向。

##### 根据字符返回位置

字符串所有的方法，都不会修改字符串本身

```js
str.indexOf('要查找的字符', [起始位置])
str.lastIndexOf('要查找的字符', [起始位置])
```



##### 查找某个字符出现的位置以及次数

```js
var str = 'abcefoxyozzoppp';
var index = str.indexOf('o');
var count = 0;
while(index !== -1) {
    console.log(index);
    count++;
    index = str.indexOf('o' + index + 1 );
    
}
```

##### 根据位置返回字符

1. charAt(index) 根据位置返回字符

```js
str.charAt(index);
```

2. charCodeAt(index) 根据位置返回字符的ASCII码

可以用来判断用户按下了哪一个键

```js
str.charCodeAt(index);
```

3. str[index] (H5新增)

```js
str[index];
```

##### 字符串拼接以及截取

1. concat(str1,str2,...) 拼接

```js
var str1 = 'andy';
var str = 'lucy';

str.concat(str1);
```

2. substr(起始位置, 截取长度) 截取

```js
var str = '字符串拼接操作';

var str1 = str.substr(2,2);
```

##### 替换字符串

```js
// 只会替换查找到的第一个
replace('被替换的字符', '替换为的字符')

var str= 'andy'；
str.replace('a', '0');
```

##### 字符转换为数组

```js
split('分隔符');

var str = 'red-head-package';
var list = split('-');
// 分隔符的类型取决于字符串中使用的什么样式的分隔符
```

##### 大小写转换

```js
// toUpperCase()

// toLowerCase()
```

### 简单数据类型与复杂数据类型

简单数据类型又叫基本数据类型或值类型，复杂数据类型又叫做引用数据类型

- 值类型：在存储时变量中存储的是值本身（string/number/boolean/undefind/null）

> [!CAUTION]
>
> null 的返回值是空object

- 引用类型：在存储时变量中存储的仅仅是地址，通过 new 关键字创建的对象都是复杂数据类型

#### 堆和栈

- 堆：存储复杂类型（对象），
- 栈：存放简单类型，

> [!CAUTION]
>
> 在JavaScript没有堆和栈的概念

#### 内存分配

- 简单数据类型存放时在栈的内部开辟一个空间，直接存放变量的值

- 复杂数据类型首先将值的地址存放在站里面，并在堆里面开辟空间存放值

#### 参数传递

- 简单数据类型传参是直接将值在变量之间传递，对不同变量的操作，只会影响到当前的变量，对其他变量无影响
- 复杂数据类型参数间传递的是保存在变量中的地址，变量最终会指向同一个地址，一次，对于任何一个变量的修改，都能改变原来的值，其他变量的值也会相应改变。







## Web API

### API与Web API

API：应用程序编程接口

Web API：操作浏览器与页面元素（BOM和DOM）

### DOM简介

DOM（Document Object Model）：文档对象模型，可以改变文档的结构、样式、内容

DOM树：

<img src="E:\GitMind\DOM树结构.png" style="zoom:40%;" />

节点：网页中所有的内容都叫作节点（node）

元素：每一个标签就是一个元素（element）

#### 获取元素

1. 通过 `id` 获取

```js
// getElementById('id') id是大小写敏感的字符串
var div = document.getElementById('id');
// 返回值是元素对象
```

> [!CAUTION]
>
> console.dir(),打印返回的元素对象，更好的查看属性和方法

2. 根据标签名获取

```js
// getElementsByTagName('标签名')
var li = document.getElementsByTagName('li');

// 获取的 element 元素标签下的所有 li
var li = element.getElementsByTagName('li');
```

> [!IMPORTANT]
>
> - 得到的元素对象是动态的
> - 返回值是以伪数组形式存储的元素对象集合

3. H5方式

```js
//  getElementsByClassName('class') 类名
var btn = document.getElementsByClassName('类名');

// querySelector('') 返回选择器的第一个元素
document.querySelector('element');
document.querySelector('.class');
document.querySelector('#id');

// querySelectorAll('') 返回选择器的所有元素
```

> [!IMPORTANT]
>
> querySelector('')中的选择器规则：
>
> 类选择器前必须有 `.`
>
> id选择器前必须有 `#`
>
> 标签的直接书写标签名

#### 获取特殊元素

1. 获取 `body`

```js
var body = document.body;
```

2. 获取 `html`

```js
var html = document.documentElement;
```

#### 事件基础

事件：触发响应的一种机制

事件的组成：事件源、事件处理程序、事件类型

##### 执行事件的步骤

1. 获取事件源
2. 注册事件（绑定事件）
3. 添加事件处理函数

```js
// 获取事件源
var btn = document.querySelector(button);

// 绑定事件
btn.onclick

// 添加事件处理函数
btn.onclick = function() {
    alert('我被点击了~');
}
```

#### 操作元素

##### 改变元素内容

innerText innerHtml

```js
element.innerText = '文本'；
element.innerHtml = '文本';
```

> [!IMPORTANT]
>
> 区别：
>
> 1. innerText不识别html标签，它会将修改内容里的标签直接显示出来，同时他也会将获取到的内容里的html标签去除
> 2. innerText会将获取到的内容里的换行去除
> 3. innerHtml不存在上述问题

##### 修改元素属性

1. 获取元素对象
2. 绑定事件
3. 修改元素对象属性值

``` js
// 获取元素
var img = querySelector('img');
var btn = querySelector('button');

// 绑定事件
btn.onclick = function() {
    img.src = 'https://www.w3c.com/';
}
```

##### 获取/修改表单元素值

表单里面的值是通过 `value` 修改的

```js
var password = document.querySelector('input[type="password"]');
btn.onclick = function() {
    // 获取表单元素的值
    console.log(password.value);
};

// 修改表单元素内容
username.value = "admin";
password.value = "123456";
```

##### 修改样式属性

1. element.style.属性名='属性值' 使用少量样式的修改

```js
var div = document.querySelector('div');
div.onclick = function() {
    div.style.color = '#fff';
    div.style.fontSize = '18px';
}
// 该方法属于行内样式，权重较高
```

> [!CAUTION]
>
> 对于多个单词构成的属性名，采用驼峰命名法书写，例如：
>
> fontSize、backgroundColor 等
>
> 区别于 CSS 属性的写法

2. element.className 适用大量样式的修改

```js
var btn = document.querySelect('button');

btn.onclick = function() {
    div.className = 'price';
}
```

> [!CAUTION]
>
> 1. calssName会覆盖原来的类名，如果想保留原来的，必须将原来的类名也写上
> 2. 需要提前定义好需要的样式的类名
> 3. 在书写类名时，类名前不要加 `.`

##### 获取自定义属性

**获取属性值**：

1. element.属性	内置属性
2. element.getAttribute('属性');    自定义属性
3. ==(H5)==`element.dataset.自定义属性名`  或  `element.dataset['自定义属性名']`

> [!NOTE]
>
> 1. dataset 获取到的是一个以 data- 开头的自定义属性的集合
> 2. 如果自定义属性由多个单词构成，用dataset获取时采用驼峰命名法

==区别==：

element.属性 获取到的是元素自带的属性

getAttribute('属性'); 获取到的是开发者自己添加的属性值(兼容性获取)

##### 设置/移除自定义属性值

**设置属性值**：

1. element.属性 = '值';	内置属性
2. element.setAttribute('属性', '值');        主要针对自定义属性

**移除属性**：

element.removeAttribute('属性');



==自定义属性的作用==：为了保存与使用数据，有些数据可以直接保存在页面中，没必要保存到数据库中

> [!WARNING]
>
> 自定义属性规范： `data-*`

### 节点操作

#### 概述

页面中所有的元素都是节点（node），所有的节点都可以被访问、创建、删除与修改。

每一个节点都具有节点类型（nodeType）、节点值（nodeValue）、节点名称（nodeName）。

元素节点的 nodeType 为 1

属性节点的 nodeType 为 2

文本节点的 nodeType 为 3 （文本节点包括文字、空格、换行等）	

#### 节点层级

DOM吧不同的节点划分为不同的层级，常见的是==父子兄层级关系==

1. 父级节点 parentNode

```js
var li = document.querySeletor('li');

// 父级节点
li.parentNode;
```

返回的是他的上一级节点，如果不存在上一级，返回 null

2. 子节点 childNodes （不推荐）

```js
var ul = document.querySelector('ul');

// 子节点
ul.childNodes;
```

> [!CAUTION]
>
> childNodes 返回的是标签里面所有的下一级节点，包括了元素节点、文本节点等。

```js
// children 返回所有的下一级子元素节点
ul.children
```

3. 第一个子节点与最后一个子节点

```js
// 第一个子节点 firstChilad
// 最后一个子节点 lastChild

// IE9+ 支持
// 返回第一个子元素节点 firstElementChild
ul.firstElementChild

// 返回最后一个子元素节点 lastElementChild
ul.lastElementChild

// 如果找不到返回 null
```

在实际的开发中，通常是通过 children[index] 来获取第一个和最后一个

4. 兄弟节点

```js
// 获取下一个兄弟节点
ul.nextSibling;

// 获取上一个兄弟节点
ul.previousSibling


// IE9+ 支持
// 获取下一个元素元素兄弟节点
ul.nextElementSibling;

// 获取上一个元素兄弟节点
ul.previousElementSibling;
```

#### 创建/添加/删除节点

```js
// 创建节点
document.createElement('tagName');

// 添加节点,末尾添加
node.appendChild(child);
// 添加节点，插入到指定子节点之前
node.insertBefore(child, 指定元素);

// 删除节点
node.removeChild(child);
```

#### 复制节点

```js
node.cloneNode()
```

> [!CAUTION]
>
> 克隆后的节点必须添加之后才能显示
>
> 参数为空或者是 false 是浅拷贝，只复制节点
>
> 如果参数为 true 为深拷贝，完整的复制整个节点

总结：

在动态创建节点的时候，`innerHTML` 的效率更高（但是不能采用拼接字符串的的方式添加，`innerHTML` 每拼接一次字符串都需要开辟一次内存空间，效率会极大地降低），通过将拼接字符串保存至数组中，最后在将数组中的内容统一渲染到屏幕上。但是结构复杂

### 事件

#### 注册事件

1. 传统方式

通过 事件源.on事件名 = fn() 的形式，具有唯一性，后面的会覆盖前面的。

2. 监听事件

```js
// 同一个元素可以添加多个事件。
事件源.addEventListener('EventType', fn());
```

#### 删除事件

1. 传统方式

事件源.事件名 = null;

2. 监听方法

```js
事件源.removeEventlistener('事件名', fn);

// 移除的时候不能使用匿名函数
// fn不需要加括号
function fn() {
    ...
}
```

#### DOM事件流

==事件流==：指的是从页面上接收事件的顺序。

事件的发生会在节点之间按照特定的顺序传播，这个传播过程被称之为DOM事件流。

1. 捕获阶段
2. 目标阶段
3. 冒泡阶段

JavaScript代码只能执行捕获阶段或冒泡阶段中的一个

`onclick` 和 `attachEvent` 只能得到冒泡阶段 

#### 事件对象

事件对象，即是监听函数的参数

```js
div.onclick = function(res) {
    ...
}

div.addEventListener('click', function(res) {
	...    
})
```

1. 事件对象只有有了事件参会存在，他是系统自动创建的，不需要传递参数。 
2. 事件对象是与事件相关的一系列数据的集合。
3. 事件对象名称由开发者自己命名
4. win6/7/8 通过window.event获取事件对象

#### 事件对象常见的属性和方法

- target  返回触发事件的对象

e.target 返回的是触发事件的对象

```js
div.addEventListener('click', function(e) {
    console.log(e.target);
})
```

**注意**：`target` 返回的是触发事件的对象，而 `this` 返回的是绑定事件的对象

- type  返回事件的类型

```js
div.addEventListener('click', function(e) {
    console.log(e.type);
})
```

- 阻止默认行为

```js
div.addEventListener('click', function(e) {
    e.preventDefault(); // 标准，低版本浏览器不支持
})
```

```js
// e.returnValue 非标准
div.onclick = function(e) {
     e = e || window.event;
     e.preventDefault(); // 标准，低版本浏览器不支持
     e.returnValue;
}
// return false 也能阻止默认事件，尽量放在最后一句
```

- stopPropagation() 阻止事件冒泡

```js
son.addEventListener('click', function(e) {
    alert('son');
    e.stopPropagation();	// 标准 不支持低版本浏览器
    e.cancelBubble = true;	// 适用于低版本 非标准
})
```

#### 事件委托

事件委托也称为事件代理，在`jQuery`里面称为事件委派

**原理：**

==不给每个子结点单独设置事件监听器，而是给父节点设置事件监听器，然后利用冒泡原理影响每个子节点==

**作用**：

只进行了一次DOM操作，提高了程序的性能

#### 禁止选中文字、禁止右键菜单

1. contextmenu 控制如何显示上下文菜单

```js
// 禁止右键菜单
document.addEventListener('contextmenu', function(e) {
    e.preventDefaule();
})
```

2. selectstart 开始选择

```js
// 禁止选中
document.addEventListener('selectstart', function(e) {
    e.preventDefaule();
})
```

#### 获得鼠标在页面中的坐标

1. e.clientX / e.clientY 

获取鼠标相对于可视区顶部的坐标，坐标不会因页面滚动而改变。

2. e.pageX / e.pageY

获取鼠标相对于文档顶部的坐标

#### 常用键盘事件

1. 按键弹起时触发 onkeyup

```js
document.onkeyup = function() {
    console.log();
}
```

2. 按键按下时触发 onkeydown / onkeypress

```js
document.onkeydown = function() {
    console.log();
}

// 不能识别功能键
document.onkeypress = function() {
    console.log();
}
// 执行顺序： onkeydown onkeypress onkeyup
```

#### 键盘事件对象

keyup与keydown事件不区分字母大小写，因此，通过 keyCode 获取到的ASCII码值是一样的

> [!CAUTION]
>
> 在实际开发中，我么更多的使用的是keydown和keyup，他们能识别所有的键

### BOM概述

window对象是浏览器的顶级对象，有双重角色

1. js访问浏览器窗口的一个接口
2. 是一个全局变量，在全局作用域中的变量、函数，都会变成window对象的属性和方法
3. 在window下存在着一个空的属性`name` 

### 页面加载事件

当文档页面全部加载完毕才会触发该事件（包括 css images）

```js
// 传统注册方式，只能页面上只能出现一次
window.onload = function() {
    ...
}；

//	H5
window.addEventlistener('load', function() {
    ...
})

// 仅当DOM加载完毕时触发，不包含 css images flash
document.addEventListener('DOMContentLoaded', function() {
    ...
})
```

### 调整窗口大小

只要浏览器的窗口大小发生了变化，就会触发事件

```js
window.onresize = function() {}
window.addEventListener('resize', function() {})
```

### 定时器

- setTimeout()
- setInterval()

```js
window.setTimeout(回调函数, [延迟的毫秒数])
//
setTimeout(function() {}, 2000);

function fn() {};
setTimeout(fn, 2000);
```

> [!CAUTION]
>
> 1.  window 可以省略
> 2. 延时时间是毫秒，省略立即执行
> 3. 调用函数可以写在外面，在里面直接写函数名
> 4. 页面上可能哟有很多定时器，通常会给定时器一个名字

定时器里面的函数常称为回调函数，等待定时器时间结束才会执行该函数。

```js
window.setInterval(回调函数, [间隔的毫秒数]);
```

setInterval() 会重复的调用一个函数，每隔一个特定时间，就会调用一次

#### 清除定时器

```js
window.clearTimeout(timeoutID);

window.clearInterval(tintervalID);
```

1. window 可以省略
2. timeout是定时器的名字

#### this指向问题

- 一般情况下，this指向的是调用它的对象
- 在全局作用域和普通函数中，this指向wimdow（定时器中的this指向window）
- 方法中的this，谁调用指向谁
- 构造函数中，this指向实例化出的对象

### js执行队列

JavaScript是典型的单线程语言。

单线程就带来了任务排队执行的问题，如果执行时间过长，就会造成页面渲染不连贯，导致页面加载阻塞。

#### 同步与异步

H5提出了Web Worker 标准，允许JavaScript创建多个线程。

**同步：**程序执行的顺序与任务排列的顺序是相同的

**异步：**同一时间，同时进行多个任务，多任务多线程

**同步任务**

同步任务会放到主线程的执行栈里

**异步任务**

js的异步是通过回调函数来实现的

一般而言，异步任务有三种类型：

- 普通事件 ，click、resize等
- 资源加载 ，load、error等
- 定时器

异步任务相关的回调函数添加到==任务队列（消息队列）==中

**js执行机制**

1. 先执行主线程执行栈里的同步任务
2. 将异步任务（回调函数）放到任务队列中
3. 待主线程任务执行完毕，查看任务队列，将任务队列里的任务调到主线程进行执行

### location对象

window为用户提供了一个location属性，用于获取和设置窗体的URL，可以解析URL。返回值为对象，因此称他为location对象。

1. location.href	返回地址
2. location.host        返回主机
3. location.search      返回参数
4. location.port
5. location.pathname
6. location.hash        锚点

#### 跳转页面

```js
var btn = document.querySelector('button');

btn.addEventListener('click', function() {
    // 给定locatin.href一个地址就能实现页面的跳转
    location.href = 'url';
})
```

#### 获取URL参数

```js
// 获取参数
var pramas = location.search.substr(1);

// 分割字符串为数组
var arr = parama.split('=');
```

#### location对象的方法

- location.assign() 跟href 一样可以实现页面跳转

```js
btn.addEventListener('click', function() {
    // 记录浏览历史，可以实现后退功能
    locayion.assign('url');
})
```

- location.replace() 替换当前页面，也能实现页面跳转，但是不记录浏览历史，不支持回退
- location.reload() 重新加载页面，如果参数为空或者false，相当于刷新按钮；如果参数为true代表强制刷新。

### navigator对象

navigator对象包含有关浏览器的信息，他有很多属性，我们最常用的是userAgent，该属性可以返回由客户机发送服务器的user-agent的头部值。

### history对象

与浏览器的历史进行交互，该对象包含用户访问过的URL

- history.back() 回退
- history.forward() 前进

- history.go(参数) 如果参数为1，就前进一步。如果为-1，就后退一步

### PC端网页特效

#### 元素偏移量 offset

动态获取元素的位置、大小等

- 获取元素相对于带有定位的父元素的位置
- 获得元素自身的大小（宽/高）
- 返回值不带单位

**属性**

1. 获取距离父元素（带定位）顶部和左侧的距离

```js
// 以带有点位的父级为准，否则以body 为准
element.offsetTop
element.offsetLeft
```

2. 获取元素的大小

```js
// 该属性返回的值包含 border contenrt padding 三部分
element.offsetWidth
element.offsetHeight
```

3. 获取带有定位的父级元素

```js
// 如果父级元素没有定位，则返回body，一级一级的向上搜索
element.offsetParent

// 返回的是最近一级的父级元素
element.parentNode
```

offset与style的区别：

- style只能得到行内样式表的样式，offset可以得到任何样式表里的样式
- style返回的值是带单位的字符串，offset得到的是不带单位的数字
- style获得的数值不包含 border padding，offset包含 border padding
- style可读可写，offset是只读

因此，想要获取元素的大小位置，用offset；想要修改大小位置，用style。

#### 元素可视区 client

动态得到元素的边框大小、元素大小

- element.clientTop    返回元素上边框大小
- element.clientLeft   返回元素左边框的大小
- element.clientWidth    不包含边框，返回值不带单位
- element.clientHeight   不包含边框，返回值不带单位

#### 元素滚动 scrpll

动态获取元素的大小、滚动距离等

- scrollHeigth/scrollWidth   不包含边框，返回值不带单位，返回的是实际内容的宽高
- scrollTop   返回被卷去的头部的高度，返回值不带单位
- scrollLeft  返回被卷去的左侧的距离

#### 动画的封装

mouseenter()与mouseover()的区别

mouseover是能向上冒泡的，而mouseenter不能

##### 实现原理

通过定时器（setInterval()）不断地移动盒子的位置

实现步骤：

1. 获取当前盒子位置
2. 让盒子在当前位置上移动一个距离
3. 利用定时器不断重复上述操作
4. 定时器结束条件

##### 简单动画封装

```js
// 示例
function move(obj, target) {
    var obj = document.querySelector(target);
    var timer = setInterval(function() {
        if(obj.offsetLeft >= 400) {
            clearInterval(timer);
        }
        obj.style.left = obj.offsetLeft + 1 + 'px';
    }, 20)
}
```

##### 不同对象添加不同定时器

不同的对象调用函数里的定时器的时候，都会产生一个变量，且每个元素的变量名都相同。（弊端）

传入的参数 obj 是一个元素对象，通过给对象添加添加属性的方式，一方面避免了重复声明变量，另一方面解决了不同对象重复变量名的问题

```js
// 示例
/*
	obj = {}
	添加属性与方法
	obj.name
	obj.say = function() {}	
*/
function move(obj, target) {
    // 为防止用户多次触发定时器动画，每次触发的时候，都会将上一次定时器清除
    clearInterval(obj.timer);
    // 添加属性方式加装定时器
    var obj = document.querySelector('"'+obj+'"');
    obj.timer = setInterval(function() {
        if(obj.offsetLeft >= 400) {
            clearInterval(obj.timer);
        }
        obj.style.left = obj.offsetLeft + 1 + 'px';
    }, 20)
}
```

##### 缓动效果

缓动动画就是让元素的速度有所变化，最常见的就是让速度慢下来

实现原理：

1. 让元素每次移动的距离不断地减小，最终停止
2. 移动距离： [（目标值 - 当前位置）/ 固定值] 作为一次的步长
3. 盒子到达目标位置停止

##### 动画的回调函数

```js
function move(obj, target, callback) {
    ...
};
move(div, 800, function(){
    ...
});
```

等待动画结束，执行回调函数

回调函数应该在定时器结束之后，开始执行

### 立即执行函数

```js
(function() {})()
(function() {} ())
```

作用：创建一个独立的作用域

立即执行函数不需要调用，也可以传递参数进去

多个连续的立即执行函数，需要用`;`隔开

### 网页轮播图的实现

1. 将内部的 `li` 进行浮动显示，改变父级盒子宽度，使 `li` 能在同一行上显示，将底部的焦点以及左右两侧的箭头定位到父级盒子内部

### 节流阀

防止轮播图按钮连续点击造成播放过快

目的：当上一个函数动画执行完毕，再去执行下一个函数动画，让事件无法连续出发

核心：通过回调函数，添加一个变量来控制，锁住函数和解锁函数

```js
var flag = true;
element.addEventListener('event', function() {
    if(flag) {
        flage = false;
        animate(x1, x2, claaback){
            ....
        }
    }
})

animate(z,b,function() {
    flage = true;
})
```

### 移动端网页特效

#### 触屏事件 touch

```js
// 触摸事件 touchstart
element.addEventListener('touchstart', function() {})

// 手指移动 touchmove
element.addEventListener('touchmove', function() {})

// 手指离开 touchend
element.addEventListener('touchend', function() {})
```

#### 触摸事件对象

- touches 正在触摸屏幕的所有手指的列表
- targetTouches  正在触摸当前DOM元素的手指列表
- changedTouches  手指状态发生改变的列表。从无到有，或从有到无

在实际开发中，经常使用的是 targetTouches

#### 拖动元素

1. 初始化盒子的坐标，手指的坐标
2. 获取到手指在屏幕上的坐标`touchstart`，pageX/pageY；盒子在屏幕上的位置。
3. 计算手指的移动距离，重置盒子位置坐标

```js
var div = document.auerySelector("div");

var startX = 0;
var startY = 0;
var x = 0;
var y = 0;

div.addEventListener('touchstart', function(e) {
    startX = e.targetTouches[0].pageX;
    startY = e.targetTouches[0].pageY;
    x = this.offsetLeft;
    y = this.offsetTop;
})

div.addEventListener('touchmove', function(e) {
    moveX = e.targetTouches[0] - startX;
    moveY = e.targetTouches[0] - startY;
    this.style.left = x + moveX + 'px';
    this.style.top = y + moveY + 'px';
})
```

#### 移动端轮播图







#### click 300ms 延时问题

由于在手机上为了对图片或者网页进行缩放行为，双击屏幕便能进行缩放功能，但是，手机判定用户是否在双击屏幕的标准是，第一次敲击屏幕与第二次敲击屏幕间隔300ms。 

1. 禁用缩放

user-scalable = "no"

2. 封装点击函数

```js
function tap(obj, claaback) {
    var startTime = 0;
    obj.addEventListener('touchstart', function(e) {
        startTime = Date.now();
    })
    var isMove = false;
    obj.addEventListener('touchmove', function() {
        isMove = true;
    })
    var times = Date.now() - startTime;
    obj.addEventListener('touchend', function() {
        if(times < 150 && !isMove) {
            callback && callback();
        }
        isMove = true;
        startTime = 0;
    })
}

tap(element, function() {});
```

#### fastclick 插件

所谓插件，就是为了解决某个特定问题出现的，功能单一的JavaScript文件

解决click 延时300ms问题

#### swiper 插件

触摸滑动插件

#### zy.media.js 插件

移动端视频插件

### 移动端开发框架

前端常用的框架有 bootstrap Vue Angular React等，技能开发PC端，也能开发移动端。

#### Bootstrap　轮播图

TARGET:[JavaScript 插件 · Bootstrap v3 中文文档 | Bootstrap 中文网 (bootcss.com)](https://v3.bootcss.com/javascript/#collapse)

### 本地存储

1. 数据存储在用户的浏览器中
2. 设置、存储方便，甚至页面刷新都不会丢失数据
3. 容量较大，sessionStorage约5M，localStorage约20M
4. 只能存储字符串，可以将对象 `JSON.stringify()`编码后存储

#### window.sessionStorage

生命周期：关闭浏览器窗口

同一个窗口下数据可共享，以键值对的形式存储

```js
// 存储数据
sessionStorage.setItem(key,value)

var val = input.value;
sessionStorage.setItem('name', val);

// 获取数据
sessionStorage.getItem(key)

sessionStorage.getItem("name");

// 删除数据
sessionStorage.removeItem(key)

sessionStorage.removeItem("name");

// 清除所有数据
sessionStorage.clear()

sessionStorage.clear();
```

#### window.localStorage

生命周期：永久，除非手动删除

同一浏览器多窗口共享数据，以键值对的形式存储

```js
// 存储数据
localStorage.setItem(key,value)

var val = input.value;
localStorage.setItem('name', val);

// 获取数据
localStorage.getItem(key)

localStorage.getItem("name");

// 删除数据
localStorage.removeItem(key)

localStorage.removeItem("name");

// 清除所有数据
localStorage.clear()

localStorage.clear();
```



## jQuery

库：预先封装好的一个特定的集合（函数）

### 概念

jQuery中封装了JavaScript常用的一些代码

- 轻量（大小只有几十kb）
- 跨浏览器兼容
- 链式编程、隐式迭代
- 免费、开源

### 基本使用

Target：[jQuery](https://jquery.com/)

引入

```js
<script src="../Jquery.js"></script>
// 引入位置只能处于整个文档的最后面，等待所有DOM元素加载完毕
```

#### jQuery入口函数

- 等待页面DOM元素加载完毕，再去执行js

```js
// 等待DOM加载完毕
$(document).ready(function() {
    
})

// 等待DOM加载完毕
$(function() {
    
})
```

> [!NOTE]
>
> 1. 等待DOM结构渲染完毕，无需等待外部所有资源加载完毕
> 2. 相当于原生中的`DOMContentLoaded`
> 3. 不同的是，load事件需要等待外部文档、js文件、css文件、图片资源加载完毕。

#### jQuery顶级对象 `$`

1. `$` 是jQuery的别称，也可以使用 `jQuery`
2. `$` 相当于原生中的 window ，通过`$`将原生对象封装成jQuery对象

#### jQuery对象 / DOM对象

1. DOM对象，通过JavaScript方式获取来的对象

```js
// DOM对象
var btn = document.querySelector('button');
```

2. jQuery对象，通过jQuery方式获取来的对象

```js
// jQuery对象
$('button');
```

3. ==jQuery对象只能使用jQuery的方法，DOM对象只能使用原生的属性和方法==

```js
// DOM对象
var btn = document.querySelector('button');
// jQuery对象
$('button');

btn.style.display = 'hidden';
$('button').hide();

// 不存在一下书写方式
$('button').style.display = 'hidden';
btn.style.hide();
```

jQuery 对象和 DOM 对象的相互转换

1. DOM 转 jQuery

   1. 直接获取

      `$('button')`

   2. 转换已经得到的DOM对象

      var btn = document.querySelector('button');

      `$(btn);`

2. jQuery 转 DOM
   1. $('vedio')[index]	jQuery获取到的对象是一个以伪数组形式存储的对象集合
   2. $('vedio').get(index)

### jQuery常用 API

#### jQuery基础选择器

```js
$("选择器")	// 选择器的书写格式与CSS相同
```

#### 隐式迭代

将匹配的所有元素内部进行遍历所有元素，所有的元素执行相同的方法

#### jQuery 筛选选择器

```js
<ul>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
</ul>
```

1. `:first` 选择第一个元素

```js
$("ul li:first"); // 获取 ul 里的第一个 li
```

2. `:eq(index)` 获取序号为 index 的元素

```js
$("ul li:eq(3)"); // 获取 ul 里的索引为3的 li
```

3. `:odd` 获取索引号为奇数的元素

```js
$("ul li:odd");
```

4. `:even` 获取索引号为偶数的元素

```js
$("ul li:even");
```

5. `:last` 获取到最后一个元素

#### jQuery 筛选方法

1. `parent()` 查找当前元素的父级

```js
$('li').parent();
// 返回离当前元素最近的上一级元素
```

2. `children()` 查找里当前元素最近的下一级

```js
// 查找当前元素的下一级类名为 text 的元素
$(".lists").children('.text');
```

3. `find()` 查找当前元素指定的所有后代

```js
// 查找当前标签里，所有类名为 price 的元素
$('.lists').find('.price');
```

4. `siblings()` 查找与当前元素同级的其他元素

```js
<ol>
    <li></li>
    <li class="item"></li>
	<li></li>
</ol>

$("ol .item").siblings('li');
```

5. `nextAll()` 查找与当前元素同级的，在当前元素之后的所有元素

```js
<ol>
    <li></li>
    <li class="item"></li>
	<li></li>
</ol>

$("ol .item").nextAll('li');
```

6. `prevAll()` 查找与当前元素同级的，在当前元素之前的所有元素

```js
<ol>
    <li></li>
    <li class="item"></li>
	<li></li>
</ol>

$("ol .item").prevAll('li');
```

7. `eq(index)`

```js
$("ol li").eq(2);
// 等价于
$("ol li:eq(2)");
```

#### jQuery 里的排他思想

```js
$('button').click(function() {
    $(this).css("background", "pink");
    $(this).siblings("buttton").css("background", "");
})
```

#### 链式编程

简化代码结构

```js
$('button').click(function() {
    // 自己变色
    $(this).css("background", "pink").siblings().css("background", "");
    // 兄弟变色
    $(this).siblings().css("background", "");
})
```

> [!CAUTION]
>
> 要注意执行对象到底是谁。

### jQuery样式操作

#### 操作 CSS 方法

jQuery 可以操作 CSS 方法进行简单的元素样式修改；也可以操作类，修改多个样式

1. 参数只写属性名，则返回属性值，不做修改

```js
$('button').css('color');
```

2. 修改样式

```js
$(function() {
    $('button').css('color', '#fff');
})
```

> [!CAUTION]
>
> 属性名必须加引号
>
> 属性名与属性值之间通过 `,` 间隔
>
> 如果属性值为数字，可以不用加引号和单位

3. 参数以对象像是表示，方便操作多种样式

```js
$(function() {
    $("button").css({
        "color":"#fff",
        "font-size":"20px"
    });
})
```

> [!CAUTION]
>
> 属性名与属性值之间用 `:` 间隔
>
> 不同的属性之间通过 `,` 间隔
>
> 属性名可以不用加引号，如果属性名是多个单词组成，必须采用驼峰命名法
>
> 属性值如果为数字可以不加引号和单位

#### 设置类样式方法

需要提前在CSS中把类书写好

```js
// 添加类
$("div").addClass("类名");
// 类名前不要加 .

// 移除类
$("div").removeClass("类名");

// 切换类，有删除，没有添加
$("div").toggleClass("类名");
```

#### 类操作与 className 的区别

原生里面的 calssName 会覆盖掉原来标签的类名

addClass 相当于在原来的基础上追加类名

jQuery 的类操作只是对指定的类名进行操作，不会影响到标签中其他的类名。

### jQuery 效果

#### 显示与隐藏

```js
// 显示
show([speed], [easing], [fn])

// 隐藏
hide([speed], [easing], [fn])

// 切换
toggle([speed], [easing], [fn])

// 一般情况下参数不会加
```

#### 滑动

```js
// 下拉
slideDown([speed], [easing], [fn])

// 上拉
slideUp([speed], [easing], [fn])

// 滑动切换
slideToggle([speed], [easing], [fn])
```

##### 事件切换

```js
hover([over,][out])

$("div").hover(function() {
    // 鼠标经过
    $(this).slideDown();
}, function() {
    // 鼠标离开
    $(this).sildeUp();
})

// 如果 hover 中只存在一个函数，则鼠标经过和离开都会触发
$("div").hover(function() {
    $(this).sildeToggle();
})
```

over: 鼠标经过触发(相当于 mouseenter)

out: 鼠标离开触发(相当于 mouseleave)

#### 动画队列及停止排队方法

##### 动画队列

动画或效果一旦出发就会执行，如果频繁出发，动画或效果就会排队执行

##### 停止排队

```js
// 停止动画或效果
stop()

$("div").hover(function() {
    $(this).stop().sildeToggle();
})
```

> [!CAUTION]
>
> ==注意：==stop()写到动画或效果的前面，表示停止上一次的动画或效果。

#### 淡入淡出

```js
// 淡入
fadeIn([speed], [easing], [fn])

// 淡出
fadeOut([speed], [easing], [fn])

// 淡入淡出切换
fadeToggle([speed], [easing], [fn])

// 修改透明度
fadeTo([[speed], opacity, [easing], [fn]])
// speed opacity 必选参数
```

#### 自定义动画

```js
animate(params, [speed], [easing], [fn])
```

params: 想要修改的样式属性，以对象的形式传递。属性名可以不带引号，如果由多个单词构成采用驼峰命名法

```js
$(function() {
    $("div").animation({
        left: 500,
        top: 200
    })
})
```

### 属性操作

#### 设置和获取固有属性

```js
$(function() {
    // 获取属性值
    $('element').prop('属性名');
    // 设置属性值
    $('element').prop('属性名', '属性值');
    
    // 获取元素自定义属性
    $('element').attr('属性名');
    // 设置属性值
    $('element').attr('属性名', '属性值');
})
```

#### 数据缓存 data()

data() 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都将被移除。

该方法将数据存放到了元素的缓存里面。

```js
$('element').data('属性名', '属性值');

console.log($('element').data('属性名'));
```

除此之外，还可以获取到H5的自定义属性，不需要写`data-`

### 元素内容的获取与修改

主要针对元素的内容和表单值

- 普通元素的内容 html() / text()

```js
// 获取
$('element').html();
$('element').text();

// 修改内容
$('element').html('value');
$('element').text('value');
```

html() 同时获取元素标签与内容

text() 只获取标签的内容

- 表单元素值  val()

```js
// 获取
$('element').val();

// 修改
$('element').val('value');
```

### 遍历对象

```js
$('element').each(function(index, domEle) {})
// index 元素索引号
// domElement 每个DOM元素对象，不是jQuery对象
// 想要使用jQuery方法，需要给这个DOM元素转换为jQuery对象
```

```js
var arr = ["red", "yellow", "blue"];

$(function() {
    $('ul li').each(function(i, domEle) {
        // domEle是DOM对象，使用jQuery方法必须转为jQuery对象
        $(domEle).css("color", arr[i]);
    })
})
```

```js
$.each(object, function(index, element) {})
// 该方法可用于遍历任何对象。主要用于数据处理
// index 元素的索引号
// element 遍历内容
```

```js
var arr = ["red", "yellow", "blue"];

$(function() {
    $.each(arr, function(i, e) {
        console.log(i);	// arr元素的序号
        console.log(e);	// arr元素的值
    })
})
```

### 创建/添加/删除元素

```js
// 创建元素
$("标签名");

var li = $("<li></li>");

// 添加元素
// (1)内部添加
// 将元素放到目标元素内部的最后面
$('element').append("需要添加的标签");
// 将元素放到目标元素内部的最前面
$('element').prepend("需要添加的标签");

$("ul").append(li);
$("ul").prepend(li);
// (2)外部添加
// 放到目标元素的后面
$('element').after("标签名");
// 放到目标元素的前面
$('element').before("标签名");

// 删除元素
// 删除元素本身
$('element').remove();
// 删除匹配元素的子节点
$('element').empty();
$('element').html("");
```

> [!CAUTION]
>
> 内部添加元素生成以后，他们是父子关系。
>
> 外部添加元素生成以后，他们是兄弟关系。

### 尺寸/位置操作

#### 尺寸

```js
// 只能得到 content 的宽度和高度，不包含 border margin
$('element').width();
$('element').height();

// 修改 width/height
$('element').width(number);

// 包含 padding
$('element').innerWidth();

// content boeder padding
$('element').outerWidth();
// 当 outerWidth() 的参数为true时包含 margin
```

- 返回值是数字类型
- 参数可以不用写单位

#### 位置

1. offset() 设置或获取元素偏移（相对于文档）

```js
$('选择器').offset();
// 获取位置
$('.son').offset().top;
$(.son).offset({
    top: 100px;
    left: 50px;
})
```

2. position()

获取到相对于带有定位的父级盒子的坐标，若不存在带有定位的父级，则返回相对于文档的坐标

该方法只能获取不能设置

```js
$('.son').position();
```

3. 被卷去的头部/被卷去的左侧

```js
// 
$(function() {
    $(window).scroll(function() {
        // scrollTop() 被卷去的头部
        console.log($(document).scrollTop());
    })
})
```

返回顶部

```js
$("body, html").stop().animate({
    scrollTop: 0
})
```

> [!CAUTION]
>
> 只有元素才能够做动画，document 是不起作用的

### 事件

#### 事件注册

1. 单个事件注册

```js
element.事件(function() {})

// mouseover mouseout blur focus change keydown keyup resize scroll
$('div').click(function() {
    
})
```

#### 事件处理 on() 绑定事件

on() 方法在匹配元素上绑定一个或多个事件处理函数

```js
element.on(events, [selector], fn);
```

- events:一个或者多个用空格分割的事件类型
- selector:元素的子元素选择器
- fn:回调函数，绑定在元素身上的监听函数

**优势**

1. 可以绑定多个事件，多个事件处理函数

```js
$("div").on({
    mouseout: function() {
        ...
    },
    click: function() {
        ...
    }
})

$("div").on("mouseover mouseout", function() {
    ...
})
```

2. 可以实现事件委派操作

```js
// 事件是绑定在 ul 身上的，触发事件的对象是 li
$('ul').on('click', 'li', function() {
  ...  
})
```

3. 给动态创建的元素绑定事件

```js
$("ul li").on("click", "li", function() {
    ....
});

var li = $("<li></li>");
$("ul").append(li);
```

####  解绑事件

off() 方法可以移除通过 on() 方法添加的事件处理程序

```js
// 若参数为空，将移除所有的事件
$('选择器').off();
$("div").off();

// 解除指定的事件
$('选择器').off("事件名");
$("div").off('click');

// 解除事件委托
$('选择器').off('事件名', '子元素');
$("ul").off('click', 'li');
```

如果事件只触发一次，可以使用 one() 来绑定事件

```js
$("选择器").one('事件', function() {})
```

#### 自动触发事件

```js
// 1
element.click();	// 简写形式
// 2
element.trigger('事件');
// 3 
element.triggerHandler('事件');	// 不会触发元素的默认行为，前两种会触发元素的默认行为
```

#### 事件对象

该处的与原生的JavaScript一致，可以参照原生JavaScript Web API

### 其他方法

#### 对象拷贝

如果想把对象拷贝给另一个对象使用，可以使用 `$.extend()` 方法

```js
$.extend([deep], target, obj1, [objN]);
```

- deep: 为 true 是深拷贝，默认为浅拷贝
- target: 目标对象（粘贴）
- obj1: 源对象（复制）

拷贝会覆盖掉 target 里面冲突的的数据

浅拷贝只是将源对象的复杂数据类型的地址，拷贝给了 target ，修改目标对象会影响源对象。

深拷贝将源对象的数据完全的拷贝给目标对象，且不会覆盖目标对象的数据，产生一个新的对象。

#### 多库共存

jQuery使用 `$` 作为标识符，其他的库可能也会使用`$` 作为标识符，这样一起使用就会引发冲突

在一个页面中引用多个库，当这些库使用相同的变量名时，可能会引发冲突，这就是多库共存。

1. 把 jQuery 里面的 $ 统一改成 jQuery
2. 为 jQuery 变量命名新的名称 `$.noConflict()`,`var xx = $.noConflict();` 

#### 插件

必须先引入jQuery文件才能使用插件

**==TARGET：==**

jQuery插件库：[jQuery插件库-收集最全最新最好的jQuery插件 (jq22.com)](https://www.jq22.com/)

jQuery之家：[[jQuery之家-自由分享jQuery、html5、css3的插件库 (htmleaf.com)](http://www.htmleaf.com/)](http://www.htmleaf.com/jQuery/)

**使用：**

1. 下载插件包
2. 根据插件包里的demo文件引入需要的js、css文件，以及内嵌的css、js。
3. 复制demo里的HTML结构
4. 根据需要，修改HTML里资源文件位置

##### 图片懒加载

图片使用延时加载，可提高网页下载速度。减轻服务器负担。

当图片滑动到可视的区域在进行图片的显示

通过jQuery插件加载使用懒加载

##### 全屏滚动



##### bootstrap组件

bootstrap是依赖于jQuery开发的，因此，使用bootstrap组键的时候，必须引入jQuery



## 面向对象

编程思想分为两种：

1. 面向对象
2. 面向过程

**面向过程编程POP(Process Oriented Programming)**：按照预先分析的步骤，按照不够解决问题。

- 优点：性能好
- 缺点：代码复用性差、不易扩展、可维护性差

**面向对象编程OOP(Object Oriented Programming)**：按照对象的功能来划分问题，按照功能解决问题。

- 优点：低耦合、代码复用性好、可维护性强、易扩展
- 缺点：性能低

面向对象的特性：

1. 封装性
2. 继承性
3. 多态性（不同的情况下有着不同的状态）

### 类和对象

编程特点：

1. 对事物抽象化（类）
2. 实例化（对象）

**对象：**

一组无需的相关==属性==（特征）和==方法==（行为）的集合，所有的事物皆是对象，一个特定的事物

**类：**

某一类对象的公共属性和方法的集合

#### 创建类/对象

```js
// 创建类
class 类名 {
    // ...
}

// 实例化对象
var obj = new 类名();
```

#### 类的constructor()构造函数

constructor() 方法是类的构造函数，==用于传递参数，返回实例对象==，通过 new 生成对象时会自动调用该方法。如果没有显式定义，类的内部会自动创建一个 conatructor().

```js
class Start {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

var obj = new Start('周杰伦', 20);
```

> [!CAUTION]
>
> 1. 类名的首字母大写
> 2. 类里面有一个 constructor() 函数，可以接受参数，返回实例对象
> 3. 只要通过 new 产生一个实例，就会自动调用constructor()函数，如果没有写该函数，类会自动生成该函数。

#### 添加方法

```js
class Start {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    say(words) {
        console.log(words);
    }
}

var obj = new Start('zjl', 30);
zjl.say('告白气球');
```

> [!WARNING]
>
> 1. 类内部的的所有函数都不需要 function
> 2. 类内部的函数之间不需要逗号间隔

### 类的继承

子类可以继承父类的属性和方法

**关键字：**extends

```js
class Father {
    
}

class Son extends Father {	// 继承父类的属性和方法
    
}
```

**关键字**：super

用于访问和调用对象父类上的函数。==可以调用父类的构造函数==，也可以调用父类的普通函数。

```js
class Father {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    sum() {
        console.log(this.x + this.y);
    }
}

class Son extends Father {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

var son = new Son(1, 2);
son.sum();
// 由于 this 的指向不同，导致实参传递不到父类，在子类对象调用父类的函数时父类无法获得参数，程序报错。
```

```js
class Son extends Father {
    constructor(x, y) {
        super(x, y);	// 调用父类的构造函数
    }
    console.log(super.say()); // 调用父类的普通函数
}
```

> [!NOTE]
>
> 1. 继承中，实例化的子类对象调用方法时，先去查看自己的类中是否有该方法，如果没有，再去父类中去查看

#### 继承与扩展

```js
class Son extends Father {	// 继承
    constructor(x, y) {
        // 调用父类的构造函数
        super(x, y);
        this.x = x;
        this.y = y;
    }
    // 子类自己的方法
    sub() {
        console.log(this.x - this.y);
    }
}

var son = new Son();
son.sum(1,2);	// 3
son.sub(3,2);	// 1
```

> [!CAUTION]
>
> 利用 super 调用父类的构造函数的时候，super 必须在子类的 this 之前

#### 使用类的两个注意点

1. 类没有变量提升，必须先有类，再有实例
2. 类里面的共有属性和方法在使用的时候一定要加 this

```js
class Father {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        // 实例化子类时使用公共方法
        this.sum();
    }
    sum() {
        console.log(this.x + this.y);
    }
}
```

```js
class Start {
    constructor(name, age) {
        this.name = name;
        this.age = age;
        this.btn = document.querySelector('button');
        // 若在调用 say 时加上括号，再点击按钮时就会执行函数
        // say 不加括号，再点击按钮后再执行函数
        this.btn.onclick = this.say;
    }
    say(words) {
        console.log(words);
    }
}

var obj = new Start('zjl', 30);
```

3. 类里面 this 的指向问题

constructor() 用于接收参数，返回一个实例化对象，因此，constructor() 里面的 this 指向的是实例化的对象。	

在公共方法里的 this 指向的是他的调用者

在某些时候，普通方法里的 this 指向的已不再是constructor，为了后续能使用constructor里面的属性，可以将 this 保存到一个全局变量里面

```js
var ak;
class Start {
    constructor(name, age) {
        // 将constructor里的this保存到全局变量ak中
        ak = this;
        this.name = name;
        this.age = age;
        this.btn = document.querySelector('button');
        // 若在调用 say 时加上括号，再点击按钮时就会执行函数
        // say 不加括号，再点击按钮后再执行函数
        this.btn.onclick = this.say;
    }
    say(words) {
        // 此处的this指向的是 btn，this.name不存在
        console.log(this.name + '唱歌');
        
        console.log(ak.name + '唱歌');
    }
}
```

####  案例

面向对象的Tab栏切换

利用 insertAdjacentHTML() 直接把字符串格式的元素添加到父元素中

```js
element.insertAdjacentHTML(position, text);
// position 是相对于元素的位置
// 1.beforebegin 元素自身的前面
// 2.affterbegin 插入到元素内部的第一个子节点之前
// 3.beforeend 插入到元素内部最后一个子节点之后
// 4.affterend 元素自身之后
```

### 构造函数和原型

#### 概述

在ES6之前，对象不是基于类创建的，而是用一种称为构造函数的特殊函数来定义对象和他们的特征。

#### 构造函数

是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总是与 new 一起使用

- 实例成员：构造函数内部通过 this 添加的成员就是实例成员。实例成员只能通过实例化的对象来访问，不能通过构造函数来访问实例成员。
- 静态成员：通过构造函数本身添加的成员。静态成员只能通过构造函数来访问，不能通过实例化对象来访问静态成员。

#### 原型对象 prototype

构造函数的问题：存在浪费内存的问题

构造函数通过原型分配的函数是所有对象所共享的。

JavaScript规定，==每一个构造函数都有一个`prototype`属性==，指向另一个对象。这个`prototype`就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。

==我们可以把那些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法==

```js
function Start(name, age) {
    this.name = name;
    this.age = age;
}
// 将不会发生变化的方法定义在原型身上
Start.prototype.sing = function() {}
```

> [!IMPORTANT]
>
> 一般情况下，公共的属性可以放到构造函数里面，但是公共的方法我们需要放到原型对象里面

#### 对象原型 `__proto__`

<span style="color:red">对象都会有一个`__proto__`</span>指向构造函数的`prototype`原型对象，之所以对象可以使用构造函数的prototype原型对象的属性和方法，就是因为由`__proto__`原型的存在。 

方法的查找规则：

1. 先查看实例化对象的身上是否存某种方法，存在就去执行
2. 如果不存在某种方法，因为有`__proto__`的存在，会去构造函数的prototype身上查找

#### constructor 构造函数

<span style="color:red">对象原型（`__proto__`）</span>和<span style="color:red">构造函数原型对象（prototype）</span>里面都有一个<span style="color:red">constructor</span>属性，constructor我们称之为构造函数，因为它指回构造函数本身。

constructor主要是记录该对象引用自哪一个对象函数。

很多情况下，我们需要手动的利用 constructor 属性指回原来的构造函数。

```js
Star.prototype = {
    constructor: Start,
    movie: function() {},
    sing: function() {}
}
// 如果修改了原型对象，给原型对象赋值了一个新的对象，就必须手动的利用constructor指回原来的构造函数。
```

#### 原型链

<img src="E:\Picture\原型链.png" style="zoom:50%;" />

#### JavaScript的成员查找机制

```js
function Fate(name, sex) {
    this.name = name;
    this.sex = sex
}
Fate.prototype.skills = function() {};
// Fate.prototype.age = 18;
var saber = new Fate('阿尔托莉雅·潘德拉贡', '女');
// saber.age = 18;

console.log(saber.age);
```

1. 当访问一个对象的属性时（包括方法），首先查找对象本身有无该属性
2. 如果没有就查找他的原型（prototype原型对象）
3. 如果没有查找原型对象的原型（Object原型对象）
4. 如果没有，最后为空对象（null），返回值 undefind

`__proto__`对象原型的意义就在于它提供了一条查找对象成员的一种机制，或者是一条路线。

#### 原型对象的 this 指向

原型对象里的 this 指向的是实例对象

#### 扩展内置对象

通过原型对象，可以对原来的内置对象进行扩展自定义方法



#### 继承

ES6之前没有提供 extends 的时候，通过构造函数+原型对象模拟实现继承，称为组合继承。

##### call()

- 调用函数，并修改函数运行时的 this 指向

```js
fun.call(thisArg, arg1, arg2, ...)
```

thisArg:当前调用函数的 this 指向的对象

argN:参数

```js
function fate() {
    name: 'saber'
}
// 调用函数
// 1
fate();
// 2
fate.call();

var ling = new Object();
// 改变函数中的 this 指向
fate.call(ling);
```

##### 借用构造函数继承父类型属性

原理：将父构造函数在子构造函数中调用，并且修改父构造函数的this指向

```js
function Father(uname, age) {
    this.uname = uname;
    this.age = age;
}
Father.prototype.money = function() {
    
}

function Son(uname, age) {
    // 调用父构造函数，修改this指向
    Father.call(this, uname, age);
}
```

##### 借用原型对象继承父类型的方法

原理：通过父构造函数实例化对象赋值给子构造函数的原型对象（prototype）的方式访问父构造函数的方法

```js
// 该方法进行的是地址传递，修改子类方法的同时，父类也会受到影响
Son.prototype = Father.prototype;
// 通过父类的实例，访问到原型里的方法，因为二者的地址不是同一个，方便子类扩展自己的方法
Son.prototype = new Father();
// 这种方法通过对象的形式修改了Son的原型里的constructor的指向，需要重新修改
Son.prototype.constructor = Son;
// 扩展方法	
Son.prototype.exam = function() {
    
}
```

### ES5新增方法

#### 数组方法

迭代方法：forEach()、map()、filter()、some()、every()

- forEach()

```js
array.forEach(function(currentvalue, index, arr))
// currentvalue 数组当前项的值
// index 当前项的索引号
// arr 数组本身
```

```js
var arr = [1,2,3,4,56];

arr.forEach(fountion(){
            ...
            })
```

- filter()

filter()方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，==主要用于筛选数组==

返回的是一个新的数组

```js
array.filter(function(value, index[, arr]) {});
// value 数组元素的值
// index 数组元素的索引号
```

```js
var newArr = arr.filter(function(value, index) {
    return value>10;
})
```

- some()

用于检测数组中的元素是否满足指定的条件,一旦找到，立马跳出循环，返回结果

返回值是布尔类型，查找到为true,否则为false

```js
array.some(function(currentvalue, index, arr){})
```

```js
var flag = arr.some(function(currentvalue, index, arr) {
    return currentvalue>10;
})
```

some()与forEach()的区别：

- 在forEach()里面的return语句不能阻止循环的进行

#### 字符串方法

- trim()

去除字符串两端的空白字符,不会去除中间空格

返回一个新字符串，不影响原来的字符串

```js
str.trim();

var str = '   xx   ';
var str1 = str.trim();
```

#### 对象方法

- Object.keys()

用于获取对象身上所有的属性

返回值是一个由属性名组成的数组

```js
Object.keys(obj);
```

```js
var saber = {
    name: '',
    age: 18,
    sex: '女'
}

var arr = Object.keys(saber);
```

- Object.defineProperty()

定义对象中新属性或修改原有属性

```js
Object.defineProperty(obj, property, descriptor)
```

参数：

- obj:（必选）目标对象
- property:(必选)属性
- descriptor:(必选)属性的特性

> [!IMPORTANT]
>
> descriptor说明：
>
> 以对象的形式书写，可选属性：
>
> - value:设置属性值，默认为 undefined
> - writable:值是否可重写，（true|false）默认为false
> - enumerable:目标属性是否可以被枚举，（true|false）默认为false
> - configurable:目标属性是否可以被删除或再次修改特性（true|false）默认为false

### 函数进阶

#### 函数的定义与调用

```js
// 函数的定义
// 1.命名函数
function fn() {}
// 2.匿名函数
var fn = function() {}
// 3.构造器 Function('参数1','参数2','函数体')
var fn = new Function();
```

> [!CAUTION]
>
> 不管是参数还是函数体，都需要加引号
>
> 所有的函数都是 Function 的实例对象

```js
// 函数的调用方式
// 1.普通函数
fn(); // fn.call();
// 2.对象的方法
obj.fn();
// 3.构造函数
new 构造函数名();
// 4.绑定事件函数
btn.onclick = function() {};
// 5.定时器函数
setInterval(function() {}, 2000);
// 6.立即执行函数
(function() {})();
```

#### 改变函数内部的 this 指向

bind()、call()、apply()

- apply()

调用一个函数，改变函数的 this 指向

```js
fun.apply(thisArg, [argsArray])
```

- thisArg:this指向的对象
- argsArray:传递的值，必须包含在数组里面
- 返回值是函数的返回值

应用：求数组的最大值

```js
var arr = [1,2,3,4,5,6,78];

// 不需要改变this指向的时候，参数可以填null
// 严格模式下，因该给定一个确定的对象
Math.max.apply(Math, arr);
```

- bind()

改变函数内部this的指向，不会调用函数

```js
fun.bind(thisArg, arg1, arg2, ...);
```

- thisArg:this指向的对象
- argN:传递的参数
- 返回值是指定的this和初始化参数改造的==原函数拷贝==

```js
// 按钮点击后禁用3s
var btn = document.querySelector('button');

btn.onclick = function() {
    // 禁用按钮
    this.disabled = true;
    setTimeout(function() {		// 定时器里的this指向的是window对象
        this.disabled = false;
        // 解禁的时间都定时器决定，不会立马执行
    }.bind(this), 3000);
}
```

#### 严格模式

JavaScript除提供正常模式以外，还提供了严格模式（strict mode）。ES5的严格模式是采用具有限制性的JavaScript变体的一种方式，即在严格的条件下执行JavaScript代码。

严格模式在IE10以上的版本才会得到支持

严格模式对正常的JavaScript语义做了一些更改：

1. 消除了JavaScript语法的一些不合理、不严谨之处，减小了一些怪异行为。
2. 消除了代码运行的一些不安全之处
3. 提高编译器效率，增加运行速度。
4. 禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来版本的JavaScript做好铺垫

#### 开启严格模式

严格模式可以应用到整个脚本或者个别函数中，因此可以将严格模式划分为==为脚本开启严格模式==和==为函数开启严格模式==两种情况

- 为脚本开启严格模式

```js
// 在所有语句前书写特定语句
"use strict"; 
```

- 为函数开启严格模式

```js
// 在函数体的最前面书写 “use strict”
(function() {
    "use strict";
})()
```

#### 严格模式的变化

- 变量规定

  - 正常模式下，如果一个变量没有声明就赋值，默认成为全局变量。严格模式禁止使用这种用法，变量必须先声明，再使用。
  - 严禁删除已经声明的变量

  ```js
  num = 10;	//严格模式下禁用
  var num = 10;
  
  delete num;	// 禁止删除
  ```

  this指向问题

  - 在普通模式下，全局作用域中的this指向window。严格模式下，全局作用域中，函数中的this指向undefined
  - 普通模式下，构造函数可以不加new调用，当普通函数使用，this只想全局对象。严格模式下，构造函数不加new调用，this会报错。new实例化之后的this指向实例化对象。
  - 定时器里的this指向window
  - 事件、对象中的还是指向调用者

- 函数变化

  - 函数不能有重名的参数
  - 函数声明必须在顶层，新版的JavaScript会引入“块级作用域”。为了与新版接轨，不允许再非函数的代码块内声明函数（循环、判断等，可以在函数内部嵌套函数）。

#### 高阶函数

**<span style="color:red">高阶函数</span>**是对其他函数进行操作的函数，它<span style="color:red">接收函数作为参数</span>或<span style="color:red">将函数作为返回值输出</span>

函数也是一种数据类型，同样可以作为参数，传递给另外一个函数使用。最典型的就是作为回调函数。

#### 闭包

- 什么是闭包？

<span style="color:red">闭包（closure）</span>指有权访问另一个函数作用域中变量的==函数==。被访问的函数便是闭包。

```js
function fn() {	// fn便是闭包
    var age = 10;
    
    function fun() {
        console.log(age);
    }
}
```

在chrome查看信息：

source选项卡 ——> 断点 ——> 右侧的Scope选项

- 闭包的作用

延伸了变量的作用范围

```js
function fn() {
    var age = 10;
    return function() {
        console.log(age);
    }
}

// 在外部访问函数内部的变量
var f = fn();
```

> [!CAUTION]
>
> 闭包并不是在任何时候都是好的，局部变量的产生，在函数执行完毕后就会被销毁，但是当函数一直不执行时，局部变量就会一直存在于内存空间中得不到释放，消耗内存资源，这也称为内存泄漏。
>
> ```js
> for(var i = 0;i < lis.length;i++) {
>     (function(i) {
>         // 产生闭包 点击事件触发后销毁局部变量
>         lis[i].onclick = function() {
>             console.log(i);
>         }
>     })(i);
> }
> ```

#### 递归

由于递归很容易发生“栈溢出（stack overflow）”错误，所以必须要添加推出条件（return）



### 正则表达式

<span style="color:red">正则表达式（Regular Expression）</span>是用于匹配字符串中字符组合的模式。在JavaScript中，正则表达式也是对象。

- 创建正则表达式

```js
// 1.通过构造函数创建
var reg = new RegExp(/表达式/);

// 2.通过字面量创建
var 变量名 = /表达式/;
```

- 测试正则表达式

```js
// test()正则对象方法，检测字符串是否符合该规则，返回值为布尔类型。
regexp_obj.test(str);
// str为要测试的文本
```

#### 正则表达式中的特殊字符

一个正则表达式可以由简单的字符构成，也可以是简单和特殊字符的组合。其中，特殊字符也被称之为==元字符==

- 边界符

```js
// ^ 开始位置
// $ 结束位置

var eg = /^abc$/;
```

- 字符类

```js
// [-]匹配可选范围中的一个或多个字符

[a-zA-Z]
[0-9]

// [^...] 取反
 
```

- 量词符

```js
// * 出现0次或多次
/^a*$/;

// + 出现1次或多次
/^a+$/;

// ? 出现一次或不出现
/^a?$/;

// {} 重复特定次数
/^a{3}$/;
// {n,} 至少重复n次
/^a{3,}$/;
// {n,m} 重复n到m次
/^a{3,6}$/;
```

#### 预定义类

- `\d`

0-9之间的任一数字

- `\D`

所有除0-9以外的任意字符

- `\w`

匹配任意的字母、数字、下划线

- `\W`

匹配除数字、字母、下划线以外的任意字符

- `\s`

匹配空格

- `\S`

匹配非空字符

#### 替换 replace()

```js
str.replace(regular_expression/current_str, target_str);

// 正则表达式的参数,按照何种模式匹配
/表达式/[switch];
/*
g:全局匹配
i:忽略大小写
gi:全局匹配+忽略大小写
*/

```

### ES6

#### 简介

2015年6月，ECMAScript发布ES2015版本，以后的每年的6月，都会发布一次版本。而ES6泛指的是ES2015以及后续版本

#### let关键字

块级作用域：由一对大括号（{}）产生的作用域

- let声明的变量只在所处的块级作用域有效

> [!CAUTION]
>
> 在一对大括号中使用 let 关键字声明的变量具有块级作用域，使用 var 声明的变量不具备块级作用域

- 防止循环变量变成全局变量
- 不存在变量提升（只能先声明在使用）
- 暂时性死区

```js
var tmp = '123';
if(true) {
    tmp = 'abc';	// tmp is not defined
    let tmp;
}
// 虽然出现了同名变量，但是在块级作用域内部通过let声明的变量，不受外部干扰，必须先定义再使用，否则或报错，这一现象被称为暂时性死区
```

#### const关键字

声明常量

- 具有块级作用域
- 声明常量时必须赋值（否则报错）
- 常量赋值后，值不能修改（对于简单数据类型，值不能更改。对于复杂数据类型，不能重新赋值，但是可以改变内部的值）

```js
const PI = 3.14;
PI = 3;	// 报错，值不可更改

const obj = {
    name: 'saber'
}
obj.name = 'master';	// 内部值可以修改

obj = {	// 报错，不能重新赋值
    name: 'master'
}
```



> [!IMPORTANT]
>
> let、var、const的区别
>
> 1. var的变量不具备块级作用域，let、const具备块级作用域
> 2. var声明的变量存在变量提升（先使用再定义），let、const不存在变量提升
> 3. 使用var、let声明的变量的值可更改，使用const声明的变量之不可更改

如果声明的变量之不需要发生变化，就是用const定义（函数、公式、特定值等）。

#### 解构赋值

ES6中允许从数组中提取值，按照对应位置，对变量进行赋值。对象也可以实现解构

- 数组解构

```js
// 基本形式
let [a,b,c] = [1,2,3];

// 如果解构不成功，变量的值为 undefined
let [f00] = [];	// undefined
let [bar,foo] = [1]	// bar=1; foo=undefined
```

- 对象结构

```js
let person = {name: "zs", age=20};
// 通过变量名匹配属性名的形式，获取到对象的属性值，赋值到变量中
let {name, age} = person;

// 给变量起别名
// 通过变量左侧的属性名与对象中的属性名相匹配，将对象中属性值赋值给右侧的属性值。
let {name:myName, age:myAge} = person;

```

#### 箭头函数

```js
// 用来简化函数定义语法
() => {};
```

小括号用于放置形参，大括号是函数体。由于箭头函数没有名字，通常将他赋值给一个变量，变量的名字就是函数的名字

```js
const fn = () => {}
```

特性：

1. 如果函数体中只有一行代码，且该行代码为返回值，大括号可以省略

   ```js
   const sum = (num1,num2) => num1 + num2;
   sum(1,2);
   ```

2. 如果形参只有一个，小括号可以省略

   ```js
   const fn = a => a;
   fn(1);
   ```

箭头函数不绑定this关键字，箭头函数中的this，指向的是==函数定义位置的上下文this==

```js
const obj = {name: 'saber'};
function fn() {
    // 全局对象window下的this
    console.log(this);
    return () => {
        // 箭头函数不包含this，此处返回的是fn()中的this
        console.log(this);
    }
}
// 使用call()方法调用并改变fn()的this指向
const resFn = fn.call(obj);
resFn();
```

#### 剩余参数

如果实参数量多于形参时，可以将实参放置到一个数组中

```js
// ... 代表arys接收剩余的所有参数
function fn(num1, ...arys) {
    console.log(num1);	// 10
    console.log(arys);	// 20 30
}

fn(10, 20, 30);
```

> [!CAUTION]
>
> 箭头函数中不能使用 arguments

#### 扩展运算符(展开语法)

扩展运算符可以将数组或对象拆分为用逗号分隔的参数序列

```js
let ary = [1,2,3];
const res = ...ary;

// 结果中不含有逗号，原因是参数序列里的逗号被当作了console.log里的分隔符。
console.log(res);
```

应用：合并数组

```js
// 方法1
let arr1 = [1,2,3];
let arr2 = [4,5,6];
let arr3 = [...arr1, ...arr2];

// 方法2
arr1.push(...arr2);
```

应用：伪数组转为数组

```js
```



#### Array内置对象

- from()

from()方法，接收一个伪数组或可遍历对象，转换为数组

他的第二个参数接收一个函数

```js
arr = {
    "0": 1,
    "1": 2,
    
}

let newA = Array.from(arr, item => item + 1);
```

- find()

查找数组中第一个符合条件的元素，返回值布尔类型。查找失败返回 undefined

参数接收一个函数

```js
var arr = [1, ..., n];

arr.find((item, index) => {
    // 查找条件
})
```

- findIndex()

查找数组中第一个符合条件的数组元素的索引，没有返回 -1

```js
let index = arr.findIndex(item => item > 2);
```

- includes()

数组中是否包含指定元素，返回值布尔类型

```js
```

- startsWith()

字符串是否已指定字符开头，返回值布尔类型

- endsWith()

字符串是否已指定字符结尾，返回值布尔类型

- repeat(number)

将字符串重复指定的次数

#### 模板字符串

定义

```js
let name = ``;
```

特性：

- 可以解析变量

  ```js
  `****, ${ name }`
  ```

- 接受换行

- 模板字符串中可以调用函数

#### Set 数据结构

ES6提供了新的数据结构 Set。类似于数组，但是成员的值都是唯一的，没有重复值。

Set是一个构造器

```js
let s = new Set();	// 空的 set数据结构，创建对象时可以向内部传值
s.size	// size属性可以显示set数据结构中包含的元素个数
```

实例方法：

- add(value)

向set中添加值

- delete(value)

从set中删除值，返回一个布尔值

- has(value)

判断set中是否有指定值，返回布尔值

- clear()

清空set中的成员，无返回值

遍历set数据结构

```js
let s = new Set();
let param = s.forEach(value => value)
```

